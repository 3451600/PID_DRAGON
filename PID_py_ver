import time
import math,runloop
from spike import PrimeHub, Motor# type: ignore
from hub import port                # port.A, port.B

# portas
LEFT_PORT = port.A
RIGHT_PORT = port.B

# globals (devem ser instanciados em main)
hub = None
left_motor = None
right_motor = None

# ---------- Awaitable bool helper ----------
class AwaitableBool:
    """
    Objeto que:
    - se usado em contexto booleano (if ...), avalia como bool(self.value)
    - se awaitado (await obj), retorna self.value
    - expõe .value para acesso direto se necessário
    """
    __slots__ = ("value",)

    def __init__(self, value):
        self.value = bool(value)

    def __bool__(self):
        return bool(self.value)

    # torna o objeto awaitable: `await obj` funciona e retorna o booleano.
    def __await__(self):
        # generator that immediately returns value
        if False:
            yield None
        return self.value

    def __repr__(self):
        return "AwaitableBool({})".format(self.value)

def wrap_bool(v):
    return AwaitableBool(bool(v))

# ----- utilitários -----
def clamp(v, lo, hi):
    if v is None:
        return lo
    return max(lo, min(hi, v))

def normalize_angle(a):
    return (a + 180) % 360 - 180

def now_s():
    return time.time()

def safe_stop(m):
    try:
        if m is None:
            return
        if hasattr(m, "stop") and callable(m.stop):
            m.stop()
        elif hasattr(m, "run") and callable(m.run):
            m.run(0)
    except Exception:
        pass

def apply_motor_cmd(m, speed):
    if m is None:
        raise RuntimeError("Motor não inicializado")
    if hasattr(m, "start") and callable(m.start):
        m.start(int(speed))
    elif hasattr(m, "run") and callable(m.run):
        m.run(int(speed))
    else:
        raise RuntimeError("API do motor não encontrada (esperado start/run)")

# ----- leituras defensivas -----
def read_motor_position(m):
    if m is None:
        raise AttributeError("Motor object is None")
    for name in ("get_position", "get_degrees", "position"):
        member = getattr(m, name, None)
        if callable(member):
            val = member()
            if isinstance(val, (list, tuple)):
                val = val[0]
            return float(val)
        if member is not None and isinstance(member, (int, float)):
            return float(member)
    raise AttributeError("Nenhum getter de posição conhecido (get_position/get_degrees/position)")

def read_yaw(h):
    if h is None:
        return None
    ms = getattr(h, "motion_sensor", None)
    if ms is None:
        return None
    for name in ("get_yaw_angle", "get_yaw", "get_heading", "get_pose", "get_yaw_face", "yaw"):
        member = getattr(ms, name, None)
        if callable(member):
            try:
                v = member()
            except Exception:
                continue
            if isinstance(v, (list, tuple)):
                v = v[0]
            try:
                return float(v)
            except Exception:
                continue
        else:
            if member is not None and isinstance(member, (int, float)):
                return float(member)
    return None

# ----- tentativa defensiva de reset do yaw -----
def reset_yaw(h):
    if h is None:
        return False
    ms = getattr(h, "motion_sensor", None)
    if ms is None:
        return False

    reset_names = ("reset_yaw", "reset_yaw_angle", "reset_heading", "zero_yaw", "zero_heading")
    for name in reset_names:
        fn = getattr(ms, name, None)
        if callable(fn):
            try:
                fn()
                time.sleep(0.05)
                return True
            except Exception:
                continue

    set_fn = getattr(ms, "set_yaw", None)
    if callable(set_fn):
        try:
            set_fn(0)
            time.sleep(0.05)
            return True
        except Exception:
            pass

    return False

# ----- ramp simplificada -----
def ramp_step(current, target, accel_per_s, dt_s):
    if accel_per_s <= 0 or dt_s <= 0:
        return target
    max_delta = accel_per_s * dt_s
    diff = target - current
    if abs(diff) <= max_delta:
        return target
    return current + (max_delta if diff > 0 else -max_delta)

# ----- movimento: heading obrigatório, com reset automático -----
def move_pid(distance_cm,
            base_speed=40,
            wheel_diameter_cm=5.6,
            kp_sync=0.6,
            accel=120.0,
            decel_distance_cm=10.0,
            min_speed=8.0,
            timeout_s=10.0,
            heading_kp=1.2,
            heading_limit=20.0):
    """
    Move distância em cm. Correção por heading é obrigatória.
    Ao iniciar, tenta resetar o yaw para zero. Se não conseguir, aborta.
    Usa as variáveis globais left_motor/right_motor/hub (instanciar em main()).
    Retorna AwaitableBool (comportamento booleano síncrono e awaitable em async).
    """
    global hub, left_motor, right_motor
    lm = left_motor
    rm = right_motor
    h = hub

    if lm is None or rm is None:
        raise RuntimeError("Motores não inicializados (chame main()).")
    if h is None:
        print("ERRO: Hub não instanciado — heading é obrigatório para move_pid.")
        return wrap_bool(False)

    # reset do yaw no início (obrigatório)
    ok_reset = reset_yaw(h)
    if not ok_reset:
        print("ERRO: não foi possível resetar yaw (motion_sensor). move_pid exige reset de yaw.")
        return wrap_bool(False)

    # encontra yaw inicial (deveria ser ~0 após reset)
    initial_yaw = read_yaw(h)
    if initial_yaw is None:
        print("ERRO: motion_sensor yaw não disponível após reset — abortando.")
        return wrap_bool(False)

    wheel_circ = math.pi * wheel_diameter_cm
    target_deg = (distance_cm / wheel_circ) * 360.0
    direction = 1 if target_deg >= 0 else -1

    # leitura inicial dos encoders (se falhar, aborta)
    try:
        left_start = read_motor_position(lm)
        right_start = read_motor_position(rm)
    except Exception as e:
        print("ERRO: leitura inicial dos encoders falhou — move_pid requer encoders funcionais. (", e, ")")
        return wrap_bool(False)

    cur_l_speed = 0.0
    cur_r_speed = 0.0
    last_t = now_s()
    start_t = now_s()

    deg_per_cm = 360.0 / wheel_circ
    decel_deg_trigger = decel_distance_cm * deg_per_cm

    try:
        while True:
            t = now_s()
            dt = t - last_t
            if dt <= 0:
                dt = 1e-3
            last_t = t

            # timeout
            if t - start_t > timeout_s:
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(False)

            # leitura encoders (se falhar durante o trajeto, aborta)
            try:
                cur_left = read_motor_position(lm) - left_start
                cur_right = read_motor_position(rm) - right_start
            except Exception as e:
                print("ERRO: leitura de encoder falhou durante o movimento — abortando. (", e, ")")
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(False)

            moved_deg = (abs(cur_left) + abs(cur_right)) / 2.0
            remaining = max(0.0, abs(target_deg) - moved_deg)
            if remaining <= 0:
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(True)

            # velocidade base com desaceleração proporcional
            if remaining <= decel_deg_trigger:
                scale = remaining / decel_deg_trigger
                base = clamp(abs(base_speed) * scale, min_speed, abs(base_speed)) * (1 if direction > 0 else -1)
            else:
                base = base_speed * (1 if direction > 0 else -1)

            # sincronização entre rodas (P)
            err_sync = cur_left - cur_right
            corr_sync = kp_sync * err_sync

            # correção de heading (P obrigatória)
            cur_yaw = read_yaw(h)
            if cur_yaw is None:
                print("ERRO: leitura de yaw falhou durante o movimento — abortando.")
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(False)
            yaw_err = normalize_angle(cur_yaw - initial_yaw)
            heading_corr = clamp(heading_kp * yaw_err, -abs(heading_limit), abs(heading_limit))

            # combina correções
            desired_l = clamp(base - corr_sync - heading_corr, -100, 100)
            desired_r = clamp(base + corr_sync + heading_corr, -100, 100)

            # aplica rampa simples
            cur_l_speed = ramp_step(cur_l_speed, desired_l, accel, dt)
            cur_r_speed = ramp_step(cur_r_speed, desired_r, accel, dt)

            # envia comandos
            try:
                apply_motor_cmd(lm, cur_l_speed)
                apply_motor_cmd(rm, cur_r_speed)
            except Exception as e:
                print("ERRO ao enviar comando aos motores:", e)
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(False)

            time.sleep(0.03)
    finally:
        safe_stop(lm); safe_stop(rm)

# ----- turn PID simplificado (PD) com reset automático de yaw -----
def turn_pid(target_deg, base_speed=30, kp=1.0, kd=0.03, tol=2.0, timeout_s=6.0):
    """
    Gira até target_deg usando PD. Antes de girar, reseta o yaw para zero.
    Retorna AwaitableBool.
    """
    global hub, left_motor, right_motor
    lm = left_motor
    rm = right_motor
    h = hub

    if lm is None or rm is None:
        raise RuntimeError("Motores não inicializados (chame main()).")
    if h is None:
        print("ERRO: Hub não inicializado; turn_pid requer motion_sensor.")
        return wrap_bool(False)

    # reset do yaw antes do giro (obrigatório)
    ok_reset = reset_yaw(h)
    if not ok_reset:
        print("ERRO: não foi possível resetar yaw (motion_sensor). turn_pid abortando.")
        return wrap_bool(False)

    # quick check pós-reset
    yaw0 = read_yaw(h)
    if yaw0 is None:
        print("ERRO: motion_sensor yaw não disponível após reset; abortando.")
        return wrap_bool(False)

    t0 = now_s()
    prev_t = now_s()
    prev_err = 0.0
    target = normalize_angle(target_deg)

    try:
        while True:
            t = now_s()
            if t - t0 > timeout_s:
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(False)

            yaw = read_yaw(h)
            if yaw is None:
                print("ERRO: leitura de yaw falhou durante o giro.")
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(False)

            err = normalize_angle(target - float(yaw))
            if abs(err) <= tol:
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(True)

            dt = t - prev_t
            if dt <= 0:
                dt = 1e-3

            p = kp * err
            d = kd * ((err - prev_err) / dt)
            out = clamp(p + d, -abs(base_speed), abs(base_speed))

            lcmd = int(clamp(out, -100, 100))
            rcmd = int(clamp(-out, -100, 100))

            try:
                apply_motor_cmd(lm, lcmd)
                apply_motor_cmd(rm, rcmd)
            except Exception as e:
                print("ERRO ao enviar comando de giro:", e)
                safe_stop(lm); safe_stop(rm)
                return wrap_bool(False)

            prev_err = err
            prev_t = t
            time.sleep(0.02)
    finally:
        safe_stop(lm); safe_stop(rm)


async def main():
    # write your code here
    await move_pid(20)
    await turn_pid(90)

runloop.run(main())
